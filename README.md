## 使用

$ node test-sort-es5.js

如果安装有Babel，也可以

$ babel-node test-sort-es6.js

## 内容

* 一个普通递归的归并排序函数 recurMergeSort
* 一个尾递归的归并排序函数 tailMergeSort
* 一个尾递归的选择排序函数 tailSelectSort
* 已经编译成ESMAScript 5的代码

## 文件

* sort-es6.js, test-sort-es6.js 是ESMAScript 6的源码和测试文件

  使用 $ babel-node test-sort-es6.js测试代码

* sort-es5.js, test-sort-es5.js 是ESMAScript 5的源码和测试文件

  使用 $ node test-sort-es5.js测试代码

## 二分法

数列往往都是复杂的，成千上万百万千万的数字混合到一起。在其中找出规律排列搜索，这是一个很繁琐的事情。递归，或者说二分法的目的就是为了简化这种操作。

二分法，将数列分为两部分 A B 。然后专注处理其中的一部分，比如 A，这样的结果是处理数列的数量减少一半。然后再把 A 分为两部分，变成 C D，转向 C，把 C 再分为两部分，直到 最后的数列只剩下2个或者1个。然后比较这2个或者1个的值，完成后获得一个新的排过序的数列，然后向上回溯，回到上一层，重复这种操作。用图形来表示是这样的：

      1 2 3 4 5 6 7 8 9 
            / \
     1 2 3 4   5 6 7 8 9
       / \        / \
    1 2   3 4  5 6   7 8 9
                      / \
                   7 8   9         # 尾部                   
 
表现为一个二叉树，计算过程可以看成是这样的：

    123456789

    1234 56789

    12 34 56 78 9                  # 尾部

## 计算过程

在计算机上 1 2 3 4 5 6 7 8 这个序列的归并排序过程：

* (1 2) 表示1 2的比较结果
* | 表示二分序列

```

1 2 3 4 | 5 6 7 8

1 2 | 3 4 | 5 6 7 8

(1 2) | 3 4 | 5 6 7 8

(1 2) | (3 4) | 5 6 7 8

(1 2 3 4) | 5 6 7 8

(1 2 3 4) | 5 6 | 7 8

(1 2 3 4) | (5 6) | 7 8

(1 2 3 4) | (5 6) | (7 8)

(1 2 3 4) | (5 6 7 8)

(1 2 3 4 5 6 7 8)

```

## 尾递归优化

现在，使用尾递归，逆推回去，过程是这样的：

    1 2 | 3 4 | 5 6 | 7 8

    (1 2) | (3 4) | (5 6) | (7 8)

    (1 2 3 4) | (5 6 7 8)

    (1 2 3 4 5 6 7 8)

我们先对整个数列按照2的个数进行偶数次比较，生成一个新的数列：

[1 2 3 4 5 6 7 8 9] 每2个进行比较，生成

    [[1，2比较结果A], [3，4比较结果B], [5，6比较结果C], [7，8比较结果D], [9比较结果E]]

对新生成的数列[A, B, C, D, E]每2个进行比较，生成

    [[A，B比较结果F], [C，D比较结果G], [E比较结果H]]

对新生成的数列[F, G, H]每2个进行比较，生成

    [[F，G比较结果I], [H比较结果J]]

对新生成的数列[I, J]每2个进行比较，生成

    [[I，J比较结果K]]

K就是最后的排序数列。

## 速度优势

根据“选择排序”和“归并排序”比较，计算一个5000个数字的时间，“选择排序”花费153ms的时间，“归并排序”花费10ms的时间。

## ESMAScript 6

一定要立刻开始学习使用ESMAScript 6，不是为了生成器，我现在甚至很少用这东西。重要的是为了Tail Calls（尾递归优化）和字符串模板，以及模块加载。

在Node.js 0.10+版本上，使用[Babel](https://github.com/babel/babel)这个神奇简单易用的编译器，可以完全100%编写ESMAScript 6代码，这编译器甚至为你进行尾递归优化（帮你把尾递归代码，编译成循环代码）。

由尾递归可以得到

* 递归的简单，可理解，数学性
* 循环的性能，没有堆栈溢出


